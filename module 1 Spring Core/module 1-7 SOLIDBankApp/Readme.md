<p>Чтобы создать отличное программное обеспечение одного навыка написания кода будет мало - нужно уметь проектировать приложения. Этот проект познакомит вас с концепцией диаграмм классов <code>UML</code> и с основами <code>SOLID</code> проектирования.</p>

<p>Вам нужно будет реализовать небольшое банковское приложение на основе диаграммы классов <code>UML</code>. <code>Унифицированный язык моделирования</code> - используется в разработке программного обеспечения для визуализации архитектуры приложений. <code>UML</code> помогает программистам создавать и обсуждать с коллегами архитектуру своего приложения и является стандартом индустрии.</p>

<h3>Какие навыки вы приобретете, выполнив данный проект:</h3>

<ul>
	<li>Чтение UML диаграмм;</li>
	<li>Знание основ принципов SOLID;</li>
	<li>Сборка Spring приложения через <code>XML</code> конфигурацию;</li>
</ul>

<h2>Описание:</h2>

<p>У небольшого банка появилась для вас тестовая задача - разработать банковское приложение. Взаимодействовать с данным приложением можно через командную строку. Вам отправили <code>UML</code> диаграмму с классами, которые нужно реализовать.</p>

<blockquote>
<p>Примечание, в данном проекте нужно реализовать только классы и интерфейсы ветки, выделенной желтым цветом.</p>
</blockquote>

<p><img alt="" height="1979" name="image.png" src="https://ucarecdn.com/49cc0b65-b28d-4878-ba20-58777399e56d/" width="2008"></p>

<p>Дополнительно, архитектор проекта оставил вам сообщение:</p>

<p>Привет! Уверен, ты уже умеешь писать простые программы, теперь давай посмотрим хорошо ли ты понимаешь структуру проектов. В первую очередь, при разработке программ мы тратим много времени на изучение проблемы. Далее, мы составляем список основных операций, которые наше приложение должно выполнять. Следующий этап это проектирование приложения.</p>

<p>Отличным инструментом для визуализации кода программы является <code>UML</code> диаграмма. Она включает в себя интерфейсы, классы, их параметры и связи между ними. Для того, чтобы понять что означает каждый из типов связей, нужно знать основы парадигмы ООП. Вот <a href="https://paulrumyancev.medium.com/uml-class-diagram-arrows-guide-37e4b1bb11e" rel="nofollow noopener noreferrer">хорошая статья</a> с основными видами стрелок.</p>

<p>При проектировании мы не пишем код, мы больше описываем бизнес задачи b сущности (domain) в классах.</p>

<p>Для того чтобы понять, насколько правильно мы действуем, мы используем <code>SOLID</code> принципы.</p>

<p><a href="https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)" rel="nofollow noopener noreferrer">SOLID</a> - это аббревиатура из пяти принципов, которую описал в свое время <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D1%82%D0%B8%D0%BD,_%D0%A0%D0%BE%D0%B1%D0%B5%D1%80%D1%82_(%D0%B8%D0%BD%D0%B6%D0%B5%D0%BD%D0%B5%D1%80)" rel="nofollow noopener noreferrer">Роберт Мартин</a>:</p>

<ul>
	<li><code>S</code> (single responsibility principle, принцип единственной ответственности) — определенный класс/модуль должен решать только определенную задачу, максимально узко, но максимально хорошо. Если для выполнения своей задачи ему требуются какие-то другие ресурсы — они в него должны быть инкапсулированы (это отсылка к принципу инверсии зависимостей)</li>
	<li><code>O</code> (open-closed principle, принцип открытости/закрытости) — классы/модули должны быть открыты для расширения, но закрыты для модификации. Должна быть возможность расширить поведение, наделить новым функционалом, но при этом исходный код/логика модуля должна быть неизменной</li>
	<li><code>L</code> (Liskov substitution principle, принцип подстановки Лискова) — поведение наследующих классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для кода</li>
	<li><code>I</code> (interface segregation principle, принцип разделения интерфейса) — интерфейс с несколькими методами лучше чем интерфейс с большим количеством методов</li>
	<li><code>D</code> (dependency inversion principle, принцип инверсии зависимостей) — "завязываться" на абстракциях (интерфейсах), а не конкретных реализациях. Так же (это уже про IoC, но всё же) можно сказать, что если какому-то классу для своей работы требуется функциональность другого — есть смысл "запрашивать" её в конструкторе нашего класса используя интерфейс, под который подходит наша зависимость. Таким образом, целевая реализация опирается только на интерфейсы (не зависит от реализаций) и соответствует принципу под буквой S</li>
</ul>

<p>Каждый из принципов описывает правила, соблюдая которые, можно легко расширять ПО.</p>

<p>В данном проекте основным доменом является счет <code>Account</code>. Имеется три вида счетов: <code>Checking</code>, <code>Fixed</code>, <code>Saving</code>. Основное отличие между ними в данной программе лишь в том, что с <code>Fixed</code> счета нельзя снимать деньги. с <code>Checking</code> и <code>Saving</code> счетов можно снимать и пополнять.</p>

<p><code>AccountDAO</code> - это интерфейс, который описывает операции с базой данных. В нашем случае, все счета будут храниться в памяти - <code>MemoryAccountDAO</code>.</p>

<p>По принципу <code>LSP</code> мы создали родительский класс <code>Account</code> которые наследуется <code>AccountWithdraw</code> и <code>AccountDeposit</code>. При работе с <code>AccountWithdraw</code> можно снимать и вносить деньги. С <code>AccountDeposit</code> можно только снимать. В свою очередь <code>FixedAccount</code> наследуется от <code>AccountDeposit</code>, остальные счета наследуются от <code>AccountWithdraw</code>.</p>

<p>Каждый отдельный бизнес процесс имеет свой интерфейс <code>AccountListingService</code>, <code>AccountCreationService</code> и каждый из них имеет интерфейс для изменения данных <code>AccountDAO</code>. Это соответствует принципам <code>SOLID</code>. Каждый интерфейс занимается одной задачей, он не зависит от реализации с базой данных и его можно расширять, производя дополнительные операции над счетом внутри реализации.</p>

<p><code>TransactionDepositCLI</code>, <code>AccountBasicCLI</code>, <code>TransactionWithdrawCLI</code> - это классы, которые работают исключительно с чтением данных от пользователя. Они хранят различные интерфейсы, такие как <code>WithdrawDepositCLIUI</code>, <code>CreateAccountOperationUI</code>. В реализации этих интерфейсов от пользователя ожидается ввод данных. Конечная реализации ввода имеется в классе <code>MyCLI</code>. Здесь использован принцип <code>ISP</code>. Мы разделили <code>CLIUI</code> на мелкие интерфейсы, где каждый из <code>TransactionDepositCLI</code>, <code>AccountBasicCLI</code>, <code>TransactionWithdrawCLI</code> использует только то, что ему нужно.</p>

<p><code>BankCore</code> - это простой класс, который хранит статические значение для нашего банка. Дополнительно, у него есть метод для создания счета, который вызывает <code>AccountCreationService</code>. <code>AccountID</code> в банке увеличивается при создании новой карты.</p>

<p>Мы можем реализовывать другие виды <code>AccountDAO</code> - <code>DBAccountDAO</code>, <code>FileAccountDAO</code>. Мы можем создать новые способ коммуникации с программой - веб. Достаточно будет создать новый <code>TransactionWithdrawWeb</code> и из него вызывать <code>TransactionWithdraw</code>.</p>

<p>Теперь твоя очередь реализовать программу, основываясь на полученных знаниях.</p>

<p>P.S. Не забывай гуглить. В интернете много других примеров <code>SOLID</code>.</p>

<p>P.S.Процесс приведения кода в идеальное состояние может быть бесконечным. Могу сказать только то, что нужно много практиковаться.</p>

<p>С наилучшими пожеланиями, Джон Доу</p>

<h2>Задача:</h2>

<p>Конечная программа должна выполнять традиционные банковские операции.</p>

<p>К основным операциям, выполняемым пользователем со счетами в данной версии относятся:</p>

<ol>
	<li>Получение информации о всех счетах</li>
	<li>Создание счета</li>
</ol>

<p>Ключевые факторы при проверке проекта:</p>

<ul>
	<li>Воспользуйтесь ссылкой на <a href="https://classroom.github.com/a/7M98EYui" rel="noopener noreferrer nofollow">GitHub Classroom</a> для создания репозитория для этого задания. После выполнения задания пришлите ссылку на репозиторий ревьюеру.</li>
	<li>В репозитории должен быть <code>README.md</code> с описанием запуска программы.</li>
	<li>Классы, интерфейсы и связи должны соответствовать <code>UML</code> диаграмме.</li>
	<li>Инициализация всех классов должна происходить в <code>xml</code> файле, который будет считан <code>Spring IoC</code>.</li>
	<li><code>xml</code> файл должен находиться в директории <code>${project_path}/src/main/resources</code> с названием <code>props.xml</code>.</li>
	<li>Программа должна работать в командной строке.</li>
	<li>Пользователь может создать счет. К счетам относятся:
	<ol>
		<li>Текущий счет (CHECKING)</li>
		<li>Сберегательный счет (SAVING)</li>
		<li>Фиксированный счет (Fixed)</li>
	</ol>
	</li>
	<li>При вызове команды для создания счета, программа должна вывести результат выполнения команды (успешно, неуспешно).</li>
	<li>Пользователь может получить список всех счетов.</li>
	<li>Каждый счет имеет уникальный <code>AccountID</code>.</li>
	<li>Нумерация счетов должна начинаться с 1.</li>
</ul>

<p>Формат для <code>AccountID</code> счета:</p>

<pre>String accountNumber = String.format("%03d%06d", 1, accountID);</pre>

<blockquote>
<p>Примечание, необходимо реализовать классы и интерфейсы одной ветки, подсвеченные желтым цветом.</p>
</blockquote>

<blockquote>
<p>Примечание 2: Если у вас не получается встроить <code>scanner</code> в xml, вы можете добавить конструктор для класса <code>MyCLI</code>.</p>
</blockquote>

<pre><code>public class MyCLI {
    private Scanner scanner;

    MyCLI() {
        this.scanner = new Scanner(System.in);
    }

    MyCLI(Scanner scanner) {
        this.scanner = scanner;
    }
}</code></pre>

<p>Пример работы:</p>

<p><img alt="" height="501" name="image.png" src="https://ucarecdn.com/b21a5e4e-7170-4b0b-834d-3698c1039464/" width="1150"></p>